## 1、通用寄存器

AX = AH + AL

BX = BH + BL

CX = CH + CL

DX = DH + DL

这四个寄存器称为通用寄存器，容量为 16 bit；前八位（AH、BH、CH、DH）与后八位（AL、BL、CL、DL）又可以分为两个寄存器。 

8086 CPU 的数据线根数为 16. 那么它一次可以处理 2 种类型的数据：

1. 字节型数据 8bit —— 8 位寄存器
2. 2 byte = 16 bit —— 16 位寄存器



<span style="color:red; font-weight: bold;">NOTE：</span>

<p style="color:red;">要保证 AX、BX、CX、DX 寄存器与数据间位数的一致性<br/>
否则，就报错</p>

<img src="./img/寄存器-1.jpg"/>



### 1.1 加法运算超过寄存器的最大值如何

```assembly
mov ax,0
mov ax,93
add al,85
```

> 8 位寄存器进行 8 位运算，保存 8 位数据，结果超出后进行超出部分舍弃

```assembly
mov ax,0
mov al,93
add ax,85
```

## 2、段地址寄存器

段地址寄存器    :    偏移地址寄存器

DS                           SP

ES                           BP

SS                           SI

CS                           DI

​                                IP

​                                BX

 8086 CPU 有 20 根地址线，但是该 CPU 的段地址寄存器为 16 位，不能完全的读取到地址值，因此使用偏移地址寄存器

### 2.1 地址计算方法

> 物理地址 = 基础地址（十六进制 H） + 偏移地址（十六进制 H）
>
> 基础地址 = 段地址（十六进制 H） x 10H

### 2.2 CPU 区分指令与数据

内存不会区分指令与数据，但是 CPU 会区分指令与数据。

8086 CPU 通过将 `CS（段地址寄存器） ： IP（偏移地址寄存器）` 指向的内容当作指令处理。

#### 2.2.1 `IP 寄存器` 与指令的关系

- 一条指令有若干个字节组成

- 指令的执行过程：

  1. 8086 CPU 从 `CS : IP` 读取指令，将其存入指令寄存器
  2. `IP = IP + 所读取指令的长度`，指向下一条指令
  3. 执行指令寄存器中的内容，开始 `步骤一`

- 实现一个小功能：

  ```assembly
  mov ax,1000H
  mov bx,1000H
  mov dl,10H
  ```

  <span style="color: blue;">执行这段指令后，观察 IP 寄存器的计数变化</span>

#### 2.2.2 `jmp` 指令修改 `CS`、`IP` 寄存器的值

> `jmp` 转移指令。`jmp` 修改 `CS`、`IP` 中的值，从而决定 CPU 从那里读取指令。

```assembly
jmp XXXX:XXXX 
例如： jmp 2000:0  
      CS:IP = 2000:0000；CPU 将从 2000:0000 处开始读取指令并执行
或
jmp 寄存器
例如： jmp ax
      将 ax 寄存器中的值给 ip 寄存器
```

# 练习 6.13

## 3、debug 调试工具使用总结

|      |                                          |
| ---- | ---------------------------------------- |
| r    | 查看指令                                 |
|      | 修改寄存器中的内容                       |
| d    | 查看内存中的内容                         |
| u    | 将内存中的机器指令翻译为汇编指令         |
| a    | 以汇编指令的格式在内存中写入一条汇编指令 |
| t    | 执行当前 CS:IP 指向的机器指令            |
| e    | 改写内存中的内容                         |

# 实验一 6.15

# 实验二 6.16

