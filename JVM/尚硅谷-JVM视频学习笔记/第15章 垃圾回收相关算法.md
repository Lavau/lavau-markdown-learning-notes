[TOC]

# 15.1  标记阶段：引用计数算法

## 15.1.1  对象存活判断

根据是否有存活的引用指向某个对象判断该对象是否死亡

## 15.1.2  引用计数算法

- ### 实现

  每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况

- ### 原理

  对于一个对象A，只要任何一个变量引用对象 A，对象 A 的引用计数器就加1；引用失效，对象 A 的引用计数器减1.

  如果对象 A 的引用计数器为0，表示对象 A 没有用了，将会被回收。

- ### 优点

  - 实现简单，垃圾对象便于识别

  - 判定效率高，回收无延迟

- ### 缺点

  - 需要单独字段存储计数器，增加了内存开销

  - 每次赋值都需要更新计时器，伴随加法和减法操作，增加时间开销

  - **无法处理循环引用问题**

    这也导致 Java 的垃圾回收器没有采用这种算法

    - 举例

      <img src="E:\mdFiles\JVM\尚硅谷-JVM视频学习笔记\picture\chapter15-1.png" width="50%">

- ### 扩展

  Python 采用了这种方式

  对于循环引用问题，Python 是这样解决的：

  - 手动删除

  - 使用弱引用 `weakref` 

    （`weakref` 是 Python 提供的标准库）

# **15.2  标记阶段：可达性分析算法

可达性分析算法又名根搜索算法、追踪性垃圾收集

- 基本思路

  以根对象（GC Roots，一组很活跃的引用）为起始点，按照从上到下的方式搜索被根对象集合连接的目标对象是否可达

  使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接，搜索所走过的路径称为引用链

  在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象，其他对象为垃圾对象

（树遍历）

## 15.2.1  GC Roots

Java 中，GC Roots 包含以下几类元素：

- **虚拟机栈中引用的对象**

- **本地方法栈 JNI （本地方法）引用的对象**

- **方法区中类静态属性引用的对象**

- **方法区中常量引用的对象**

- 所用被同步锁 synchronized 持有的对象

- 虚拟机内部的引用

- 反映虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存

- 临时性加入其他对象：分代收集与局部收集（Partial GC）

  （如果只针对堆中的某一块区域进行垃圾回收，必须考虑该内存部分虚拟机内部的实现细节。该区域对象可能被其他区域的对象引用，这时需要将关联区域的对象也加入到 GC Roots 中）

# **15.3  对象的 finalization 机制

由于 `finalize()` 方法的存在，虚拟机中的对象一般处于 3 种状态：

1. 可触及

   从所有根节点开始，可以到达该对象

2. 可复活

   对象的引用被释放，但对象可能在 `finalize()` 中复活

3. 不可触及

   `finalize()` 方法被调用，并且没有复活，则进入不可触及状态

**`finalize()` 只会被调用一次**

**只有对象处于不可触及状态时才会被回收**

## 15.3.1  具体过程

判断一个对象 A 是否会被回收，至少要被标记 2 次：

1. 如果对象 A 到 GC Roots 没有引用链，则第 1 次被标记

2. 判断对象 A 是否执行 `finalize()` 方法：

   - 对象 A 没有重写 `finalize()` 方法，或 `finalize()` 已被调用，对象 A 被判定为不可触及

   - 对象 A 重写 `finalize()` 方法，且 `finalize()` 未被执行，对象 A 被插入到 F-Queue 队列中，最后被由虚拟机自动创建的、低优先级的 `Finalizer 线程` 调用

   - GC 对 F-Queue 队列中的对象进行第 2 标记。

     如果对象 A 的 `finalize()` 方法与引用链上的任一对象建立联系，在第 2 次标记后，对象 A 被移除“即将回收”集合。之后，对象会再次出现无引用存在的情况。这种情况下，`finalize()` 方法不会被再次调用，对象 A 变为不可触及态——`finalize()` 方法只能被调用一次

3. 验证代码

   ```java
   package com.atguigu.java;
   
   /**
    * description 143P——代码演示可复活的对象
    *
    * @author Leet
    * @date 2020-12-28 21:00
    **/
   public class CanReliveObj {
       public static CanReliveObj obj;
   
       @Override
       protected void finalize() throws Throwable {
           System.out.println("调用 finalize()");
           obj = this;
       }
   
       public static void main(String[] args) {
           try {
               obj = new CanReliveObj();
               obj = null;
               System.gc();
               System.out.println("第 1 次 GC");
               Thread.sleep(3000);
               if (obj != null) {
                   System.out.println("RELIVE");
               } else {
                   System.out.println("DEAD");
               }
               Thread.sleep(3000);
   
               obj = null;
               System.gc();
               System.out.println("第 2 次 GC");
               Thread.sleep(3000);
               if (obj != null) {
                   System.out.println("RELIVE");
               } else {
                   System.out.println("DEAD");
               }
           } catch (Exception e) {
   
           }
       }
   }
   ```

# 15.4  MAT 与 JProfiler 的 GC Roots 溯源



# **15.5  清除阶段：标记-清除(Mark—Sweep)算法



# **15.6  清除阶段：复制(Copying)算法

<img src="E:\mdFiles\JVM\尚硅谷-JVM视频学习笔记\picture\chapter15-2.png" width="50%">

## 15.6.1  执行过程



## 15.6.2  优点



## 15.6.3  缺点



# **15.7  清除阶段：标记-压缩(Mark—Compact)算法

<img src="E:\mdFiles\JVM\尚硅谷-JVM视频学习笔记\picture\chapter15-3.png" width="50%">

## 15.7.1  执行过程



## 15.7.2  优点



## 15.7.3  缺点



# 15.8  小结

|          | Mark—Sweep     | Mark—Compact     | Copying                             |
| -------- | -------------- | ---------------- | ----------------------------------- |
| 速度     | 中等           | 最慢             | 最快                                |
| 空间开销 | 少（堆积碎片） | 少（不堆积碎片） | 需要活对象的 2 倍大小（不堆积碎片） |
| 移动对象 | 否             | 是               | 是                                  |

- 从效率上看，复制算法是最棒的，却浪费了太多内存



# 15.9  分代收集算法



15.10  增量收集算法、分区算法