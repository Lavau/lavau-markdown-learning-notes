[TOC]

# 1.  栈、堆、方法区的交互关系

## 1.1 栈、堆、方法区的交互关系

<img src="E:\mdFiles\JVM\尚硅谷-JVM视频学习笔记\picture\chapter9-1.png" height="40%" width="40%">

Java 栈上存放实例对象的引用。引用指向 Java 堆上本对象的实际内存地址。Java 堆上该内存地址中的对象头部分有指向方法区的“指针”。



# 2.  方法区的理解

## 2.1  方法区在哪

> 《规范》中明确说明：“尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会选择进行垃圾收集或者进行压缩。”
>
> 对 Hotspot 而言，方法区还有个别名——Non-Heap，目的就是为要区分Heap。
>
> 故：**方法区看作一块独立于 Java 堆的内存区域。**

## 2.2  方法区的基本理解

1. 线程共享

2. 虚拟机在启动时被创建，物理内存空间与 Java 堆一样都是不连续的

3. 大小选择：固定、可扩展

4. 如果系统加载了太多类，可能会导致方法区溢出：

   ​	`OutOfMemoryError:PermGen space` 或 `OutOfMemoryError:Metaspace` 

5. 关闭虚拟机释放方法区的内存

## 2.3  Hotspot 中方法区的演进

<img src="E:\mdFiles\JVM\尚硅谷-JVM视频学习笔记\picture\chapter9-2.png" width="58%">

1. JDK 7 之前，习惯上把方法区称为 *永久代*

   JDK 8 之后，用 *元空间*  取代 *永久代*

2. *元空间*  与 *永久代*  都是 Hotspot 对《规范》中方法区的实现。二者并不只是名字不同，内部结构也调整了。

   两者最大的区别：**元空间使用本地内存**

# 3.  设置方法区大小与OOM

## 3.1  方法区大小

（Hotspot JDK 8 及其以后）

1. JVM 参数
   - `-XX:MetaspaceSize` 
   - `-XX:MaxMetaspaceSize`
2. 默认值依赖平台
   - windows下，`-XX:MetaspaceSize` 为 21M
   - `-XX:MaxMetaspaceSzie` 值为 -1，没有限制
3. OOM：如果元空间溢出，抛出 `OutOfMemoryError`
4. GC
   - 一旦元空间容量达到设置的值，就会触发 **Full GC**（Full GC 卸载没用的类与这些类的类加载器）
   - 并重新设置元空间容量
     - 如果释放的空间不足，在不超过 `MaxMetaspaceSize`，适当提高
     - 如果释放空间多，适当降低

```java
/**
 * description 90P——设置方法区大小的参数
 *      -XX:MetaspaceSize=100m -XX:MaxMetaSpaceSize=200m
 *
 * @author Leet
 * @date 2020-12-14 22:35
 **/
public class MethodArea {
    public static void main(String[] args) {
        try {
            Thread.sleep(100000);
        } catch (InterruptedException e) {

        }
    }
}
```

命令行参看：

<img src="E:\mdFiles\JVM\尚硅谷-JVM视频学习笔记\picture\chapter9-3.png" width="45%">

## 3.2  OOM

```java
import jdk.internal.org.objectweb.asm.ClassWriter;
import jdk.internal.org.objectweb.asm.Opcodes;

/**
 * description 91P——OOM：PermGen和OOM：Metaspace 测试
 *      -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m
 *
 * @author Leet
 * @date 2020-12-14 23:06
 **/
public class OOMTest extends ClassLoader {
    public static void main(String[] args) {
        int j = 0;
        try {
            OOMTest test = new OOMTest();
            for (int i = 0; i < 10000; i++) {
                ClassWriter classWriter = new ClassWriter(0);
                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, "class" + i, null, "java/lang/Object", null);
                byte[] code = classWriter.toByteArray();
                test.defineClass("class" + i, code, 0, code.length);
                j++;
            }
        } finally {
            System.out.println(j);
        }
    }
}

```

<img src="E:\mdFiles\JVM\尚硅谷-JVM视频学习笔记\picture\chapter9-4.png" width="70%">



# 4.  方法区的内部结构

## 4.1  方法区存储的内容

《深入理解 Java 虚拟机》中的描述：存储虚拟机已加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**

### 4.1.1  类型信息

对每个加载的类型（class、interface、enum、annotation），虚拟机在方法区存放以下信息

1. 类的修饰符
2. 全类名
3. 该类直接父类全类名
4. 该类直接接口有序列表

### 4.1.2  域信息

保存类型中所有域的相关信息（域名称、域类型、域修饰符）以及域的声明顺序

### 4.1.3  方法信息

保存类型中所有方法的相关信息以及声明顺序

- 修饰符、返回类型、方法名、按顺序的参数数量与类型

- 异常表

  每个异常处理的起始位置、代码处理在程序计数器的偏移地址、被捕获的异常类的常量池的索引

- （abstract、native 除外）方法的字节码、操作数栈、局部变量表及它的大小





# 5.  方法区使用举例



# 6.  方法区的演进细节



# 7.  方法区的垃圾回收



# 8.  总结

