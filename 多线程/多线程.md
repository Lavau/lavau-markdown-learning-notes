[TOC]

# 1.  基本概念

* 程序

  **程序** 是指令和数据组成的有序集合

* 进程

  执行一次程序的过程

  进程是系统资源分配的单元

* 线程

  一个进程包括一个或多个线程

  线程是 CPU 调度与执行的单位

  线程是独立执行的

> 注意：
>
> 多线程是指多个 CPU（即多核） 同时进行不同的任务。
>
> 一个 CPU 在同一个节点只能执行一个线程



# 2.  创建进程的方式

1. 继承 ```Thread class```
2. 实现 ```Runnable interface```
3. 实现 ```Callable interface```

> ```Thread class``` 实现了 ```Runnable interface```



JVM 允许应用程序同时执行多个执行线程

## 2.1  线程的优先级

> 每个线程都有一个优先级

 较高优先级的线程优先于优先级较低的线程执行

新线程的优先级最初设置为创建线程的优先级

当在某个线程中创建一个新的线程时，并且当且仅当创建线程是守护进程时新线程才是守护线程。 

## 2.2  main 线程停止

JVM 启动时，通常有一个非守护线程（通常调用某些指定类的名为 `main` 的方法）。  JVM 将继续执行线程，直到发生以下任一情况： 

- 已经调用了`Runtime`类的`exit`方法，并且安全管理器已经允许进行退出操作
- 所有非守护进程线程的全部死亡 

## 2.3  创建新线程

### 2.3.1  Thread

1. 继承 `Thread` 类
2. 重写 `run()` 
3. `main()` 方法 `new` 这个类并调用 `start()` 

```java
/**
 * description: 线程学习
 * @author: Leet
 * @date: 2020-11-10 23:25
 **/
public class TestThread1 extends Thread{
    
    @Override
    public void run() {
        for (int i = 0; i < 2000; i++) {
            System.out.println(String.format("%s%d", "我在看代码---", i));
        }
    }

    public static void main(String[] args) {

        new TestThread1().start();

        for (int i = 0; i < 2000; i++) {
            System.out.println(String.format("%s%d", "我在学习多线程---", i));
        }
    }
}
```

### 2.3.2  Runnable

1. 实现 `Runnable`
2. 重写 `run()`
3. 在 `main()` 中 `new` 一个这个类作为参数传给 `Thread` 对象，调用 `start()`

```java
/**
 * description: 多线程学习2
 *
 * @author: Leet
 * @date: 2020-11-10 23:39
 **/
public class TestThread2 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 2000; i++) {
            System.out.println(String.format("%s%d", "我是天才-----", i));
        }
    }

    public static void main(String[] args) {
        new Thread(new TestThread2()).start();

        for (int i = 0; i < 2000; i++) {
            System.out.println(String.format("%s%d", "不，我才是天才-----", i));
        }
    }
}
```

### 2.3.3  Callable

1. 实现 `Callable interface`
2. 重写 `call()` 方法，需抛出异常
3. 创建目标对象 XXX
4. 创建执行服务：`ExecutorService es = Executors.newFixedThreadPool(1);`
5. 提交执行：`Future<Boolean> result = es.submit(XXX);`
6. 获取结果：`boolean r = result.get();`
7. 关闭服务：`es.shutdown();`



# 3.  静态代理模式

真实对象与代理对象都实现同一个接口

代理对象代理真实角色

## 3.1  Thread class 中的代理



# 4.  lambda

* 函数式接口

  该接口只有一个方法

在使用该接口实现类的时候，就可以使用 lambda 



# 5.  线程状态

<img src="E:\mdFiles\多线程\picture\1.png" height=200px>

<img src="E:\mdFiles\多线程\picture\2.png" height=280px>

## 5.1  线程方法

<table>
    <tr>
        <td>setPriority(int newPriority)</td>
        <td>更改线程优先级</td>
    </tr>
    <tr>
        <td>static void sleep(long milis)</td>
        <td>让该线程休眠 milis ms</td>
    </tr>
    <tr>
        <td>void join()</td>
        <td>等待该线程终止</td>
    </tr>
    <tr>
        <td>static void yield()</td>
        <td>暂停该线程，执行其他线程（让贤）</td>
    </tr>
     <tr>
        <td>isAlive()</td>
        <td>该线程是否存活</td>
    </tr>
</table>

### 5.1.1  线程停止

* 利用有限的次数让线程停止
* 使用一个 `flag` （终止循环）让线程停止
* 不要使用 `stop()` 、`destory()` （被舍弃）

### 5.1.2  线程休眠

`sleep()`

需要捕获异常

sleep 不会释放锁

达到失眠时间后，该线程进入就绪状态

### 5.1.3  线程礼让

`yield()`

线程礼让：让当前线程停止，但不阻塞，变为就绪状态

礼让不一定成功

### 5.1.4  join()

合并线程，待此线程执行完，再执行其他线程（其他线程此时阻塞）

```java
/**
 * description: join() 方法测试
 * @author: Leet
 * @date: 2020-11-11 11:06
 **/
public class TestJoin implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.printf("%s%d\n", "线程 VIP 来了 ---》 ", i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new TestJoin());
        thread.start();

        for (int i = 0; i < 500; i++) {
            if (i == 200) {
                thread.join();
            }

            System.out.printf("%s%d\n", "线程 main ---》 ", i);
        }
        // main ：VIP 线程属实过分了，它自己执行那么多次，不老实排队，竟然利用自己的特权插队，这是可恶。
    }
}

```

## 5.2  观测线程状态：`Thread.State`

## 5.3  线程优先级

> Java 为每个线程提供了优先级
>
> 线程调度器按照优先级决定调度哪个线程

* **优先级只是意味着被调度概率的高低**

* 线程优先级：1~10

* 获取线程优先级

  ```getPriority()`

* 设置线程优先级

  `setPriority(int priority)`

***建议：优先级设定在`start()`前***

```java
/**
 * description: 线程优先级测试
 *
 * @author: Leet
 * @date: 2020-11-11 11:26
 **/
public class TestPriority implements Runnable {
    @Override
    public void run() {
        System.out.printf("%S 的 priority : %d\n", Thread.currentThread().getName(), Thread.currentThread().getPriority());
    }

    public static void main(String[] args) {
        System.out.printf("%S 的 priority : %d\n", Thread.currentThread().getName(), Thread.currentThread().getPriority());

        Thread thread1 = new Thread(new TestPriority(), "thread1");
        Thread thread2 = new Thread(new TestPriority(), "thread2");
        Thread thread3 = new Thread(new TestPriority(), "thread3");
        Thread thread4 = new Thread(new TestPriority(), "thread4");
        Thread thread5 = new Thread(new TestPriority(), "thread5");

        thread1.setPriority(1);
        thread2.setPriority(5);
        thread2.setPriority(9);
        thread4.setPriority(2);
        thread5.setPriority(10);

        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();
        thread5.start();
    }
}
```



