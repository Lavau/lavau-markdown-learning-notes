[TOC]



# 第一讲：基础架构——一条查询语句是如何执行的



> 概述：
>
> > 在本讲中，我学到了 MySQL 的基础架构（即第一节中的图）以及 MySQL 如何执行一条查询语句（结合第一节中的图，要明白 MySQL 的每个部分都做了哪些工作）



```sql
SELECT * FROM T WHERE ID = 10;
```

## 1. MySQL 的基础架构



<img src="./picture/MySQL 基础架构.png" height=400 />

## 2. 从基础架构图看查询语句的执行

### 2.1 连接器

1. 连接到 MySQL 服务器

   * 如果通过了，则：
     * 确定用户
     * 获知用户权限

2. 保持连接

   （无操作情况下，默认连接时长为 8 h）

### 2.2 查询缓存

建立连接后，执行语句前，先要 **查询缓存** 。

MySQL 拿到一个查询请求不是先去执行它，而是先去缓存查看是否有该语句的执行结果——如果命中，则直接返回。

缓存以 map 的形式保存：键为语句，值为执行的结果。

如果表发生了更新，则与这个表相关联的缓存会被清空。

MySQL 8 已经去除了该功能。

### 2.3 分析器

如果没有命中缓存，则执行。

1. 词法分析

   分析语句中，每个词的含义——识别每个字符串、代表含义

2. 语法分析

   根据词法分析的结果，结合语法规则，判断 SQL 语句是否符合 SQL 语法

### 2.4 优化器

- 在表中存在多个索引时，决定使用那个索引
- 在多表连接时，决定表的连接顺序

### 2.5 执行器

MySQL 通过分析器知晓你要干啥，通过优化器知晓如何做，那么接下来就要执行了。

在执行前，会对当前操作用户进行一个权限认证（查询缓存时也会如此）。

有权限就开始打开表，执行器根据表的引擎定义，使用这个引擎提供的接口：无论是否有索引，会遍历地进行 ID 值的匹配，如果匹配到，则存在结果集中。遍历完成后，将结果集返回给用户。



# 第二讲：日志系统：一条 SQL 更新语句是如何执行的？

一条查询语句走的流程，更新语句也会走一遍：执行更新语句前连接数据库。完成连接后，分析器分析语句；优化器根据分析结果告知执行器如何执行；执行器调用引擎的相关接口，完成语句的更新。

在完成语句的更新后，会把执行结果存入 **日志** 。

## 1. 日志模块

在 MySQL 中，有两个重要的日志系统：

* redo log

  redo log 属于存储引擎 InnoDB，不是 MySQL 原生的。

* binlog

  binlog 属于 Server 层

  binlog 不能进行 crash—safe，只能归档

### 1.1 redo log

一条语句更新时，InnoDB  引擎先把结果写到 redo log 中，并刷新内存，此时更新算完成了。InnoDB 在<span style="text-decoration:underline;">适当地时候</span>会把这个操作记录更新到磁盘。

其实这在 MySQL 中被称为 **WAL（Write-Ahead Logging）** 技术——即先写日志，再写磁盘。

#### 1.1.1 redo log 的“更新”

InnoDB 的 redo log 是固定大小的。

<img src="./picture/redo log.png" height=300 />

对图片的说明：

（1）、为 redo log 配置了一组文件——每个文件 1 G，共 4 个

（2）、以循环写入的方式更新 redo log：write pos 是当前记录位置，边写边后移；check point 是要擦除的位置，循环后移。

就算数据库发生异常的重启，我们也不怕——提交的纪录保存在 redo log 中，并未丢失，可以恢复。这个能力成为 **crash—safe** 。

### 1.2 redo log 与 binlog 的不同

1. 处于的层级不同

2. redo log 是物理日志——记录哪个数据页做了什么修改；

   binlog 是逻辑日志——记录更新语句的原逻辑（就是更新语句）

3. 写的方式不同：

   - redo log 是循环写，空间固定（正如 1.1.1 中所说）
   - binlog 是“追加写”

### 1.3 细看更新流程

<img src="./picture/更新语句执行流程.png" height=550 />

#### 1.3.1 数据库的“还原”

binlog 中存放的是更新逻辑，而数据库是会每隔一段时间做整库备份的。如果，某天数据崩溃，可以找到最近的一次备份，按照 binlog 把它恢复过来。

#### 1.3.2 redo log 为何做两次写入？

为了保证数据的一致性。

# 第三讲：事务隔离：为什么你改变了我看不见？

## 1. 事务的概述

### 1.1 什么是 *事务*

> 事务就是一组数据库操作要么都成功，要么都失败。

事务的支持是在存储引擎层实现的。

### 1.2 多个事务同时执行时，可能出现的问题

- 脏读

  一个事务读到其他事务 **update** 后未提交的数据

- 不可重复读

  一个事务读到其他事务 **update** 或 **delete** 后已提交的数据

- 幻读

  一个事务读到其他事务 **insert** 后已提交的数据

因此，为了解决这些问题，提出了 **隔离级别** 的概念。隔离得越严实，效率也就越低。

## 2. 事务的隔离级别

### 2.1 SQL 标准的事务隔离级别

- 读未提交（read uncommitted）

  一个事务没提交时，它做的变更能被其他事务看到

- 读已提交（read committed）

  一个事务提交后，它做的变更才能被其他事务看到

- 可重复读（repeatable read）

  一个事务执行过程中看到的数据，与它刚启动时看到的数据是一致的

- 串行化（serializable）

  对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。读写锁冲突时，必须等这个事务完成后，其他事务才能操作

#### 2.1.1 举个例子，理解事务隔离级别

```sql
CREATE TABLE t (c INT) ENGINE = InnoDB;
INSERT INTO t (c) VALUES (1);
```



<img src="./picture/事务隔离级别举例.png" height=320 />

在不同的事务隔离级别下，分析下 V1、V2、V3 的值

### 2.2 InnoDB 是这样实现事务的

* 可重复读

  在事务开始时，直接建一个视图；在执行过程中，读视图中的数据

* 读已提交

  在 SQL 语句开始执行时，创建一个视图

* 读未提交

  直接读取返回记录上的最新值

* 串行化

  通过加锁的方式，避免并行访问

## 2.3 事务隔离的实现

以 ”可重复读“  为例：

每条记录在更新时都会记录一条回滚记录。记录上的最新值，通过回滚可以得到前一个状态值。

回滚记录的版本可能会有多个。

































