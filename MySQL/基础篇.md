[TOC]



# 第一讲：基础架构——一条查询语句是如何执行的



> 概述：
>
> > 在本讲中，我学到了 MySQL 的基础架构（即第一节中的图）以及 MySQL 如何执行一条查询语句（结合第一节中的图，要明白 MySQL 的每个部分都做了哪些工作）



```sql
SELECT * FROM T WHERE ID = 10;
```

## 1. MySQL 的基础架构



<img src="./picture/MySQL 基础架构.png" height=400 />

## 2. 从基础架构图看查询语句的执行

### 2.1 连接器

1. 连接到 MySQL 服务器

   * 如果通过了，则：
     * 确定用户
     * 获知用户权限

2. 保持连接

   （无操作情况下，默认连接时长为 8 h）

### 2.2 查询缓存

建立连接后，执行语句前，先要 **查询缓存** 。

MySQL 拿到一个查询请求不是先去执行它，而是先去缓存查看是否有该语句的执行结果——如果命中，则直接返回。

缓存以 map 的形式保存：键为语句，值为执行的结果。

如果表发生了更新，则与这个表相关联的缓存会被清空。

MySQL 8 已经去除了该功能。

### 2.3 分析器

如果没有命中缓存，则执行。

1. 词法分析

   分析语句中，每个词的含义——识别每个字符串、代表含义

2. 语法分析

   根据词法分析的结果，结合语法规则，判断 SQL 语句是否符合 SQL 语法

### 2.4 优化器

- 在表中存在多个索引时，决定使用那个索引
- 在多表连接时，决定表的连接顺序

### 2.5 执行器

MySQL 通过分析器知晓你要干啥，通过优化器知晓如何做，那么接下来就要执行了。

在执行前，会对当前操作用户进行一个权限认证（查询缓存时也会如此）。

有权限就开始打开表，执行器根据表的引擎定义，使用这个引擎提供的接口：无论是否有索引，会遍历地进行 ID 值的匹配，如果匹配到，则存在结果集中。遍历完成后，将结果集返回给用户。



# 第二讲：日志系统：一条 SQL 更新语句是如何执行的？

一条查询语句走的流程，更新语句也会走一遍：执行更新语句前连接数据库。完成连接后，分析器分析语句；优化器根据分析结果告知执行器如何执行；执行器调用引擎的相关接口，完成语句的更新。

在完成语句的更新后，会把执行结果存入 **日志** 。

## 1. 日志模块

在 MySQL 中，有两个重要的日志系统：

* redo log

  redo log 属于存储引擎 InnoDB，不是 MySQL 原生的。

* binlog

  binlog 属于 Server 层

  binlog 不能进行 crash—safe，只能归档

### 1.1 redo log

一条语句更新时，InnoDB  引擎先把结果写到 redo log 中，并刷新内存，此时更新算完成了。InnoDB 在<span style="text-decoration:underline;">适当地时候</span>会把这个操作记录更新到磁盘。

其实这在 MySQL 中被称为 **WAL（Write-Ahead Logging）** 技术——即先写日志，再写磁盘。

#### 1.1.1 redo log 的“更新”

InnoDB 的 redo log 是固定大小的。

<img src="./picture/redo log.png" height=300 />

对图片的说明：

（1）、为 redo log 配置了一组文件——每个文件 1 G，共 4 个

（2）、以循环写入的方式更新 redo log：write pos 是当前记录位置，边写边后移；check point 是要擦除的位置，循环后移。

就算数据库发生异常的重启，我们也不怕——提交的纪录保存在 redo log 中，并未丢失，可以恢复。这个能力成为 **crash—safe** 。

### 1.2 redo log 与 binlog 的不同

1. 处于的层级不同

2. redo log 是物理日志——记录哪个数据页做了什么修改；

   binlog 是逻辑日志——记录更新语句的原逻辑（就是更新语句）

3. 写的方式不同：

   - redo log 是循环写，空间固定（正如 1.1.1 中所说）
   - binlog 是“追加写”

### 1.3 细看更新流程

<img src="./picture/更新语句执行流程.png" height=550 />

#### 1.3.1 数据库的“还原”

binlog 中存放的是更新逻辑，而数据库是会每隔一段时间做整库备份的。如果，某天数据崩溃，可以找到最近的一次备份，按照 binlog 把它恢复过来。

#### 1.3.2 redo log 为何做两次写入？









